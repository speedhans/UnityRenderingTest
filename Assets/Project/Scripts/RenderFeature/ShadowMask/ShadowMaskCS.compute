// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ShadowMaskCS
#pragma kernel ShadowMaskBlurCS

#pragma multi_compile _ _MAIN_LIGHT_SHADOWS
#pragma multi_compile _ _MAIN_LIGHT_SHADOWS_CASCADE

#include "CustomShadowMaskHelper.hlsl"

static half2 _uvOffset[8] =
{
    half2(0, 1),
    half2(0, -1),
    half2(1, 0),
    half2(-1, 0),
    half2(0.75, 0.75),
    half2(0.75, -0.75),
    half2(-0.75, 0.75),
    half2(-0.75, -0.75),
};

float2 _DevideValue;
float _BlurOffset;

half ComputeShadowEdge(half2 pixelPos)
{
    half atten = SampleShadowAttenuation(pixelPos / _ShadowMaskTextureSize);
    [unroll] for (int i = 0; i < 4; ++i)
    {
        atten += SampleShadowAttenuation((pixelPos + _uvOffset[i]) / _ShadowMaskTextureSize);
    }

    atten /= 5;

    return (atten < 0.8f && atten > 0.2f) ? 1 : 0;
}

[numthreads(24,24,1)]
void ShadowMaskCS(uint3 id : SV_DispatchThreadID)
{
    [unroll] for (int i = 0; i < 4; ++i)
    {
        [unroll] for (int j = 0; j < 4; ++j)
        {
            half x = (id.x + i * _DevideValue.x);
            half y = (id.y + j * _DevideValue.y);
            half2 index = half2(x, y);
            half attenuation = ComputeShadowEdge(index);
            _ShadowMaskTexture[index] = attenuation;
        }
    }
}


[numthreads(24,24,1)]
void ShadowMaskBlurCS(uint3 id : SV_DispatchThreadID)
{
    half2 index = id.xy;
    half offset = _BlurOffset;

    float color = _ShadowMaskTexture[index];
    [unroll] for (int i = 0; i < 8; ++i)
    {
        color += _ShadowMaskTexture[index + (_uvOffset[i] * offset) * _ShadowMaskTextureSize];
    }

    _ShadowMaskTexture[index] = color;
}